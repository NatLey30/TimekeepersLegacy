**Title of the Game**: "Timekeepers' Legacy"
**Genre**: 2D Adventure Game
**Game Description**:
In a dystopian future where the world is plunged into chaos, scientists discover that the only way to restore the world is by collecting valuable objects from different time periods. The player takes on the role of a brave adventurer on a mission to find these objects and change the fate of the world. However, the powerful leaders of the world have hired a villain named "Dr. Fugit" to pursue the protagonist and stop them at all costs.
Types of Scenes:
- Time Periods
In this type of scene, a significant portion of the video game unfolds. There are six different levels set in prehistory, ancient Egypt, ancient Japan, the Middle Ages, the present, and a dystopian future. In each level, there are obstacles to dodge and traps where the player can die. Additionally, the player is being pursued by the villain Dr. Fugit, and they will automatically lose if caught. The enemy serves as our AI element in the game, relentlessly chasing the player through all levels, increasing its speed if the player strays too far to ensure it never leaves the frame.
In each level, there is a special object that the player must obtain through a mini-game. Once all the special objects are collected, the player wins.
The levels are randomly assigned so that they never follow the same order, making the game less predictable.
- Mini-games
Upon finding a special object, the player must complete a thematic mini-game to collect it. Losing the mini-game does not result in the player's death and a restart; instead, they cannot retain the object, and when returning to the level, they must try again to obtain it.
These mini-games are designed not to pose significant difficulty for the player, although some are more challenging than others. Our goal in programming these mini-games was to implement various techniques learned during the course and offer a more comprehensive gaming experience.
Later on, we elaborate on the functioning of each one.
- Menu
The initial menu utilizes elements such as scrollers to provide an introduction to the game and its basic instructions. It is also possible to select the color of the enemy that will pursue the player throughout all levels.
At the bottom of the menu, icons representing each level and their respective time periods are displayed, and hovering over each icon with the mouse shows the special object to collect.
Throughout the game, UI elements allow the player to pause the game, reread mini-game instructions, and see at all times which objects they have already obtained and which ones are still missing.
Upon reaching the end of the game, having collected all objects in each level, a utopian future is displayed alongside all the obtained objects.¬

**Game Periods**:
- Dystopic Future
- Present
- Edo Period (Japan)
- Prehistory
- Ancient Egypt
**Mini-games**:
- CrossRoad – Present
  This mini-game is inspired by the famous Crossy Road, and the player must cross several lanes without getting hit. Cars are randomly generated by spawners, so the player must stop and plan their movements before crossing the road.
- HanoiTowers - Edo Period (Japan)
  We wanted to recreate the well-known Towers of Hanoi puzzle, which we encountered in our Algorithms and Data Structures course. The puzzle consists of three towers, the first with three discs, and the goal is to move all three discs to the last tower. Two rules must be considered: only one disc can be moved at a time, and a larger disc cannot be placed on top of a smaller one.
  We decided to keep it agile, giving the player only one minute to solve the puzzle in its simplest version with only three discs. This was probably one of the most challenging mini-games to program, as the logic of the puzzle was not easy to implement, and we hoped to find more online resources. To play our version, click on the tower where the disc you want to move is, and then on the tower where you want to move it.
- Pyramid Exploration - Ancient Egypt
  In this mini-game, the player must navigate an underground maze to find the pharaoh's sarcophagus. There is a one-minute countdown and many incorrect paths that lead nowhere. The player uses arrow keys, and colliders define the path to follow. Once the sarcophagus is found, the mini-game is won.
- Archery - Middle Ages
  The player has five arrows to hunt a deer in the forest. The deer moves from left to right, making the game a bit more challenging. To create a more natural effect, we created sprites that alternate, creating the illusion of the deer walking. The arrow movements are based on the mathematical formula describing their trajectory.
- SpellingBee – Prehistory:
  We wanted to create our version of one of our favorite word games, Spelling Bee, which we played a lot together. The goal is to form as many words as possible from seven letters, always including the central letter. Last year, we came up with a Python solver for the game and used it to generate lists of solutions that the game then compares to the player's answers. In our mini-game, the player is considered to have won when they find five valid words.

**Game Flow**:
The GameManager controls all scene changes, overseeing transitions between scenes to ensure the player has a coherent and smooth gaming experience. A Singleton design pattern is adopted, where a single instance of GameManager prevails throughout the game.
By centralizing management, changes in the game are consistent across all scenes. As players progress through different stages or mini-games, GameManager smoothly supervises the transitions, maintaining a sense of continuity. This not only enhances the gaming experience but also simplifies the programming structure.
The GameManager extends beyond simple scene transitions; it encapsulates vital information about the game's state, such as scores, player progress, and general variables defining the global game state. This ensures that critical information remains persistent and accessible between scenes, allowing for a coherent narrative and logical progression.
Essentially, the GameManager is the axis that connects the scattered threads of the game. Its role as a singleton ensures constant and reliable authority, guiding the game flow with precision. Whether orchestrating transitions, preserving the game's state, or managing global variables, the GameManager stands as the sentinel, strengthening the structural integrity of the entire gaming experience.
